package io.cequence.openaiscala.examples.anthropic.skills

import io.cequence.openaiscala.anthropic.domain.Message.UserMessage
import io.cequence.openaiscala.anthropic.domain.settings.AnthropicCreateMessageSettings
import io.cequence.openaiscala.anthropic.domain.skills.{Container, SkillParams, SkillSource}
import io.cequence.openaiscala.anthropic.domain.tools.Tool
import io.cequence.openaiscala.anthropic.service.{AnthropicService, AnthropicServiceFactory}
import io.cequence.openaiscala.domain.NonOpenAIModelId
import io.cequence.openaiscala.examples.ExampleBase
import io.cequence.wsclient.service.ws.Timeouts

import scala.concurrent.Future

// requires `openai-scala-anthropic-client` as a dependency and `ANTHROPIC_API_KEY` environment variable to be set
object AnthropicCreateMessageWithPptxSkill extends ExampleBase[AnthropicService] {

  private val timeout = 5 * 60 * 1000 // 5 minutes

  override protected val service: AnthropicService = AnthropicServiceFactory(
    timeouts = Some(
      Timeouts(
        requestTimeout = Some(timeout),
        readTimeout = Some(timeout)
      )
    )
  )

  private val model = NonOpenAIModelId.claude_sonnet_4_5_20250929

  override protected def run: Future[_] = {
    // Using Anthropic's built-in pptx skill to create a presentation
    val messages = Seq(
      UserMessage(
        "Create a presentation about renewable energy"
      )
    )

    val settings = AnthropicCreateMessageSettings(
      model = model,
      max_tokens = 10000,
      container = Some(
        Container(
          skills = Seq(
            SkillParams(
              skillId = "pptx",
              `type` = SkillSource.anthropic,
              version = Some("latest")
            )
          )
        )
      ),
      tools = Seq(Tool.codeExecution())
    )

    println("=" * 60)
    println("Using Anthropic's built-in pptx skill")
    println("=" * 60)

    service.createMessage(messages, settings).map { response =>
      println(s"Model: ${response.model}")
      println(s"Role: ${response.role}")
      println(s"Stop Reason: ${response.stop_reason.getOrElse("N/A")}")
      println()

      val lastBashCodeExecutionFiles =
        response.bashCodeExecutionToolFileIds.lastOption.getOrElse(
          throw new RuntimeException(
            "No successful bash code execution result found in the response."
          )
        )

      // Display generated files that are accessible via File API
      if (lastBashCodeExecutionFiles.nonEmpty) {
        println()
        println("=" * 60)
        println("Generated Files (accessible via File API):")
        println("=" * 60)

        lastBashCodeExecutionFiles.foreach { fileId =>
          println(s"  File ID: ${fileId}")
          println(s"  Status: Generated by code execution")
          println(s"  Downloadable: Yes (use downloadFile endpoint)")
          println()
        }

        println("Note: These files can be downloaded using service.downloadFile(fileId)")
        println("Note: Use service.getFileMetadata(fileId) to get filename and MIME type")
        println("Note: Generated files are downloadable, unlike user-uploaded files")
        println("=" * 60)
        println()
      }

      response.blockContents.foreach { blockContent =>
        println(s"Content Block:")
        println(s"  ${blockContent}")
        println()
      }

      println("=" * 60)
      println("Note: The pptx skill can generate presentations")
      println("Container can hold up to 8 skills")
      println("Skills are reusable across multiple requests using container.id")
      println("=" * 60)
    }
  }
}
